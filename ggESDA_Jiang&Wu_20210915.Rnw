\documentclass[article]{jss}

%% -- LaTeX packages and custom commands ---------------------------------------
%% my packages
\usepackage{graphicx} % table rotate
\usepackage{array} %table height
\usepackage{pdfpages} %include pdf


%% recommended packages
\usepackage{thumbpdf,lmodern}

%% another package (only for this demo article)
\usepackage{framed}
\usepackage{float} %for figure [H]
%% new custom commands
\newcommand{\class}[1]{`\code{#1}'}
\newcommand{\fct}[1]{\code{#1()}}
\newcommand{\imgdir}{../../../paperImage/}
%% For Sweave-based articles about R packages:
%% need no \usepackage{Sweave}
%\SweaveOpts{engine=R, eps=FALSE, keep.source = TRUE}
<<preliminaries, echo=FALSE, results=hide>>=
#options(prompt = "R> ", continue = "+  ", width = 70, useFancyQuotes = FALSE)
#library("MASS")
@


%% -- Article metainformation (author, title, ...) -----------------------------

%% - \author{} with primary affiliation
%% - \Plainauthor{} without affiliations
%% - Separate authors by \And or \AND (in \author) or by comma (in \Plainauthor).
%% - \AND starts a new line, \And does not.
\author{Bo-Syue Jiang\\National Taipei University
\And Han-Ming Wu\\National Chengchi University}
\Plainauthor{Bo-Syue Jiang,Han-Ming Wu}

%% - \title{} in title case
%% - \Plaintitle{} without LaTeX markup (if any)
%% - \Shorttitle{} with LaTeX markup (if any), used as running title
\title{ggESDA: An \proglang{R} Package for Exploratory Symbolic Data Analysis using \pkg{ggplot2}}
\Plaintitle{A Short Demo Article: Regression Models for Count Data in R}
\Shorttitle{A Short Demo Article in \proglang{R}}

%% - \Abstract{} almost as usual
\Abstract{
  This paper presents the \pkg{ggESDA} package, which we developed for exploratory symbolic data analysis in \proglang{R}. Based on \pkg{ggplot2} \cite{Wickham:2009}, the \pkg{ggESDA} package which is familiar programming structure with its parent provides a wide variety of graphical techniques such as histogram, 3D-scatterplot and radar plot. In addition, a general and  customized transformation function \code{classic2sym()} is implemented for generating a symbolic data table from classical data frame by clustering algorithm, \pkg{RSDA} \cite{Rojas:2015} function and user-defined method. wait for edit......
}

%% - \Keywords{} with LaTeX markup, at least one required
%% - \Plainkeywords{} without LaTeX markup (if necessary)
%% - Should be comma-separated and in sentence case.
\Keywords{data visualization, symbolic data analysis, exploratory data analysis, \pkg{ggplot2} extensions, interval-valued data, \proglang{R}}
\Plainkeywords{data visualization, symbolic data analysis, exploratory data analysis, ggplot2 extensions, interval-valued data, R}

%% - \Address{} of at least one author
%% - May contain multiple affiliations for each author
%%   (in extra lines, separated by \emph{and}\\).
%% - May contain multiple authors for the same affiliation
%%   (in the same first line, separated by comma).

<<dataPrepare, echo=FALSE, results=hide>>=
myLibrary <- c("ggESDA", "ggplot2", "ggthemes",
               "data.table", "grid", "gridExtra",
               "tibble", "stringr", "dplyr",
               "extrafont")
lapply(myLibrary, require, character.only = TRUE)

set.seed(20211020)
myDiamonds <- diamonds
myDiamonds.i <- classic2sym(myDiamonds)$intervalData
breastData <- data.table::fread("doc/data.csv")
@



\begin{document}
%\SweaveOpts{concordance=TRUE} 
\section{Introduction}
"In Data Science the aim is to extract new knowledge from Standard, Big, and complex data. Often these data are unstructured with variables defined on different kinds of units. They can also be multi-sources (as mixtures of numerical and textual data, with images and networks)." \cite{Diday:2018}. The statement indicates that not only conventional data but the unstructured data, also known as symbolic data, is vital for data science. Rather than the classical data represented by a single value, symbolic data with measurements on $p$ random variables can be $p$-dimensional statistical units such as hypercubes or histograms. The field of symbolic data analysis (SDA) \cite{Billard+Diday:2007} is to broaden the application aspects of statistical methodologies, extend traditional cognition of a form of data unit and build a brand-new analysis system of data science. Recent developments in the field of big data analytics have led to a renewed interest in complex structure data such as symbolic data. As shown in Figure \ref{fig:trend}, the number of researches in SDA represents an increasing trend from 1998 to 2020, which outstands the importance of it during the years.



\begin{figure}[h]	
  		\centering	 			 	 
 	 		%\includegraphics[width=1\textwidth]{\imgdir Trend_SDA_1998_to_2020.png} 
<<TrendFig, echo=FALSE, fig=TRUE, height=7, width=14>>=
mySymTop <- textGrob("Trend of symbolic data analysis", gp=gpar(fontsize=20))
d1_scienceDirect<-fread("doc\\scienceDirect_full2.csv")
sd_trend <- as.data.frame(d1_scienceDirect[,2:3])
sd_trend <- sd_trend[complete.cases(sd_trend),]
sd_trend <- sd_trend[2:24,]#without 2021
sd_trend$count <- as.numeric(str_replace(sd_trend$count, ",", ""))
#sd_trend$count <- as.numeric(sd_trend$count)
sd_trend_plot<-ggplot(data=sd_trend,aes(x=year,y=count))+geom_line(col="blue",size=1.05)+
  geom_point(size=1.3)+
  labs(title="scienceDirect")+
  scale_x_continuous(breaks=c(1998,2000,2005,2010,2015,2020))+theme_stata()+
  scale_y_continuous(breaks=c(min(sd_trend$count),400,600,800,1000,max(sd_trend$count)))+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        panel.grid.major.y = element_line(colour="grey"),
        text = element_text(size=16))

d1_PubMed<-fread("doc\\PubMed_Timeline_Results_by_Year_adjusted.csv")
PubMed <- as.data.frame(d1_PubMed[4:26,])
colnames(PubMed) <- c("year","count")
PubMed$year<-as.numeric(PubMed$year)
PubMed$count <- as.numeric(PubMed$count)
PubMed_plot<-ggplot(data=PubMed,aes(x=year,y=count))+geom_line(col="blue",size=1.05)+
  geom_point(size=1.3)+
  labs(title="PubMed")+
  scale_x_continuous(breaks=c(1998,2000,2005,2010,2015,2020))+theme_stata()+
  scale_y_continuous(breaks=c(min(PubMed$count),15,25,35,max(PubMed$count)))+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        panel.grid.major.y = element_line(colour="grey"),
        text = element_text(size=16))
marrangeGrob(list(sd_trend_plot,PubMed_plot),nrow=1,ncol=2,top=mySymTop)
@
  		\caption{The number of "symbolic data analysis" or "interval-valued data" related articles in researches and applications according to PubMed and ScienceDirect online database over time from 1998 to 2020.}   		
  		\label{fig:trend}   			 		 
\end{figure}

Among ScienceDirect, Engineering and Computer Science lead the subject areas obviously, shown in Figure \ref{fig:subjectAreas}.

\begin{figure}[h]	
  		\centering	 			 	 
 	 		%\includegraphics[width=1\textwidth]{\imgdir subjectAreas_scienceDirect.png} 
<<subjectFig, echo=FALSE, fig=TRUE, height=7, width=14>>=
subject_areas <- as.data.frame(d1_scienceDirect[,4:5] )
subject_areas <- subject_areas[1:10,]
subject_areas$sum <- as.numeric(str_replace(subject_areas$sum, ",", ""))
subject_areas<-as.data.frame(arrange(subject_areas,sum))
total<-sum(subject_areas$sum)
prop<-unlist(lapply(subject_areas$sum,FUN=function(x) round((x/total)*100,2)))
subject_areas[,"myLabels"] <- paste(subject_areas$sum,paste0("(",paste0(prop,"%"),')'))
loadfonts(device = "win")
ggplot(subject_areas,aes(x=as.factor(1:10),y=sum))+
  geom_bar(stat="identity",col="black",fill="grey70",width=0.8)+
  geom_text(aes(label=myLabels), hjust=-0.1, size=4)+
  scale_x_discrete(labels=subject_areas$name)+
  scale_y_continuous(limits = c(0,5000),breaks=seq(0,5000,500))+
  coord_flip()+
  labs(title = "Subject areas of scienceDirect from 1998 to 2020",x="Fields",y="Publish")+
  theme(panel.grid.major.y = element_blank(),
         panel.grid.minor.y = element_blank(),
         panel.grid.major.x = element_line(colour="grey"),
        panel.grid.minor.x = element_blank(),
         text = element_text(size=20,family="serif"),
        plot.background = element_rect(fill = "grey97"),
        axis.line = element_line(colour = "black",size = 0.4,linetype = "solid"),
        panel.background = element_rect(fill = "white",linetype = "solid"))
@
  		\caption{Top 10 researches and applications domains for SDA or interval-valued data (ScienceDirect) from 1998 to 2020} 
  		\label{fig:subjectAreas}   			 		 
\end{figure}


In practice, the symbolic data is often generated by aggregating massive datasets into intervals in order to make the management easy and appropriate. An interval-valued symbolic random variable $X$, taking values in interval, can be denoted such as $X = [a,b] \subset  R^{1}$, where $a \leq b$, and $a, b \in R^{1}$. Let the random variable $X$, for instance, be the weight, then $X = [50,100]$ represents the interval covering the weight of people. With the advent of big data analytic, interval-valued data is becoming more common and accessible than ever. The researches for interval-valued data such as the sign test for COVID-19 data \cite{sherwani:2021}, the prediction via regularized artificial neural network \cite{yang:2019}, a bivariate Bayesian method for regression models \cite{xu:2021}, etc.

Exploratory Data Analysis (EDA) \cite{Tukey:1977} is primarily used to see what data can reveal beyond the formal modeling or hypothesis testing task, provides an overview of raw datasets and obtains a general understanding about the variables and their relationships.


\section{Prominent SDA packages}

\subsection[RSDA]{\pkg{RSDA}}

\subsection[symbolicDA]{\pkg{symbolicDA}}

\subsection[HistDAWass]{\pkg{HistDAWass}}




\section[Basic usage of ggESDA]{Basic usage of \pkg{ggESDA}}

\pkg{ggESDA} is now available from the Github at \url{https://github.com/kiangkiangkiang/ggESDA}. All reference manual documented by exported functions and introduction vignettes can also be download here. In the following section, we are going to illustrate the functionalities and syntaxes about \pkg{ggESDA}.

\subsection[Transformation function]







\subsection{General principles}

\subsection{Multiple plot}

\subsection{Package dependencies}


\section{Application to real datasets}

\subsection{univariate}

\subsection{bivariate}

\subsection{multivariate}


\section{Conclusion}





\section{why SDA plot (weakness of classical plot)}
\subsection{sol overstike}
For the conventional exploratory data analysis, it is always a severe challenge to deal with enormous datasets because conventional displays suffered from overstrikes of data points representing the value (scatterplot type displays) or overstrikes of line segments connecting values of neighboring variables. As a consequence, exploratory symbolic data analysis (SDA) becomes a preliminary yet essential tool for summarizing the main characteristics of a data set before appropriate statistical modeling can be applied. Besides escaping the problem mentioned above, SDA can effectively reduce observations in data, which will make the study focus on what we interesting instead of unnecessary information such as Figure~\ref{fig:compare}.

\begin{figure}[H]
\centering
<<compare, echo=FALSE, fig=TRUE, height=5.2, width=7>>=
myOrder <- c(5, 4, 3, 1, 2)
myCol <- RColorBrewer::brewer.pal(5, "Blues")

a <- ggplot(myDiamonds, aes(x = carat, y = price))+
  geom_point() + theme_bw()
b <- ggInterval_scatter(myDiamonds.i, aes(x = carat, y = price)) + 
  scale_fill_manual(values = myCol[myOrder], 
                    name="Kmeans-Group", 
                    labels = c(1:5)) + theme_bw()

grid.arrange(a, b, ncol=2, widths=c(1.5, 2))
@
\caption{\label{fig:compare} Compare classical data and symbolic data}
\end{figure}

In Figure~\ref{fig:compare}, we can clearly visualize the scatter plot in the right hands, which is represented by symbolic data and aggregated by K-means \cite{Jin:2010}. 


\subsection{full information}

In the past, we would like to use barplot to visualize the frequency of categorical data, but that was merely represented the distribution of full data in that category. It cannot lead researchers to explore more details in what they are interesting such as a particular part of data, so aggregation methods play a vital role to merge the data we interesting.

However, the conventional categorical data after merging will usually be represented by mode, which will be unmeaningful to visualize and cause the loss of information that may become larger when the data or the number of factors in that category is growing on. SDA will build a histogram by calculating each factor of the category of frequency as bins to solve this kind of problem as a result. In that way, a categorical variable will never be shown as a single value at all, instead, a complete information histogram will be substituted.


\section{classical data to symbolic data}

\subsection{datasets}

We will apply the breast mass dataset, which is computed from a digitized image of a fine needle aspirate (FNA), to demonstrate how does a classical dataset transforms into a symbolic dataset. The breast mass dataset describe characteristics of the cell nuclei present in the image. It can be downloaded from the kaggle at \url{https://www.kaggle.com/uciml/breast-cancer-wisconsin-data?select=data.csv}. There are 569 observations and 32 variables in the dataset. We are going to store this dataset in \code{breastData} as data frame type in \proglang{R}, and the variables will be shown as follows:
<<show_breastData_attr>>=
colnames(breastData)
@

Except for the first two variables, they are all composed of mean, standard error, and "worst" in their own field respectively.

\subsection{K-means}

K-means clustering is a method of vector quantization, originally from signal processing, that aims to partition n observations into k clusters in which each observation belongs to the cluster with the nearest mean. In \pkg{ggESDA}, the algorithm will be based on the \pkg{stats} package, and the number of k is a parameter that user can define themself:

<<classic2sym_kmeans>>=
breastData <- dplyr::select(breastData, -id)
breastData.sym <- classic2sym(breastData, groupby = "kmeans", k = 5)
breastData.sym.i <- breastData.sym$intervalData
as.data.frame(head(breastData.sym.i[, 1:4], 5))
@

The \code{id} is unused in this case, so we remove it by \pkg{dplyr}. Then using \code{classic2sym()} to aggregate \code{breastData}. It will return several result sets include clustering result and interval-valued data, etc. The interval-valued data can be extracted by \code{$intervalData}, and it will be presented by the package of \pkg{RSDA} type.

The \code{groupby} is a parameter that determine what kind of aggregation methods will be used. Whenever the K-means method is applied, the consequent \code{k} will become meaningful, whereas the other situation is not. It is also a default method when users have no input arguments in \code{groupby}.

\subsection{Hierarchical}

The second well-known clustering algorithm is called Hierarchical clustering \cite{Cecil:1966}, also called hierarchical cluster analysis or HCA. It can be performed with a distance matrix
calculated by raw data and used to present the distance of each cluster. In basic \proglang{R} package, it is also realized by \pkg{stats}, which the \pkg{ggESDA} is based on for implementing HCA:

<<classic2sym_hclust>>=
breastData.sym <- classic2sym(breastData, groupby = "hclust")
breastData.sym.i <- breastData.sym$intervalData
@

Remark that the \code{k} parameter is not meaningful in the case without K-means clustering. In \code{classic2sym()}, the keywords of HCA is called \code{hclust}.

\subsection{particular variable}

Using a particular variable to merge different data is a common way for data analysis, too. \pkg{ggESDA} provides such as this concept in \code{classic2sym()} to analyze different factors of category variables, and merge the same factor into the symbolic data type:

<<classic2sym_parVar>>=
breastData.sym <- classic2sym(breastData, groupby = "diagnosis")
breastData.sym.i <- breastData.sym$intervalData
head(breastData.sym.i[, 1:4], 5)
@

In \code{breastData}, the only category variable is \code{diagnosis}, which means the diagnosis of breast tissues (M = malignant, B = benign). We put it as an input argument in \code{groupby} for merging different diagnosis results, and the interval-valued data of result sets will display its factor levels in row names.


\subsection{user defined}\label{userDef}

In general, users may not always use the aggregation methods we provide, thus, besides generating a particular variable for the group, \pkg{ggESDA} facilitates the process through the min data and max data that user-defined.

For the demonstration, we will build both min data and max data using \code{runif}. Generate a uniform random variable to make sure that all min data are smaller than max data:

<<classic2sym_parVar>>=
minData <- runif(100, -100, -50)
maxData <- runif(100, 50, 100)
demoData <- data.frame(min = minData, max = maxData)
demoData.sym <- classic2sym(demoData, groupby = "customize", 
                            minData = demoData$min,
                            maxData = demoData$max)

demoData.sym.i <- demoData.sym$intervalData
as.data.frame(head(demoData.sym.i, 5))
@

Then choose the \code{customize} argument in \code{groupby}, input which data are \code{minData} or \code{maxData}, and the transformation will be simply completed.

In order to simplify the process and make the preprocessing friendly, we develop this method and let the people who want to analyze symbolic data easier.


%begin : this is my table for package_compare 

\begin{table}[htbp]
  \centering
  \caption{Compare with \proglang{R} packages}
  %\rotatebox[origin=c]{90}{
  \setlength{\extrarowheight}{6pt}
  \resizebox{\textwidth}{!}{
    \begin{tabular}{|l|l|c|c|ccc|c|c|c|}
    \hline
    \toprule
    \multicolumn{1}{r}{} & \multicolumn{1}{r}{} & \multicolumn{1}{c}{\textbf{ R(4.1.0)}} & \multicolumn{1}{c}{\textbf{Transformation}} & \multicolumn{3}{c}{\textbf{EDA}} & \multicolumn{1}{c}{\textbf{Statistic}} & \multicolumn{2}{c}{\textbf{Machine learning}} \\\hline
    \multicolumn{1}{c|}{Package} & \multicolumn{1}{c|}{Reference} & Available & Transform to sym & One variable & Two variables & Multivariable & Stat. Method & Supervised & \multicolumn{1}{c}{Unsupervised} \\\hline
    RSDA  & Rojas (2015) & V     & V     & 0     & 1     & 0     & 3     & 2*    & 1* \\
    symbolicDA & Dudek (2013) & V     &       & 0     & 0     & 2*    & 2     & 1     & 1* \\
    HistDAWass & Irpino (2015) & V     & V     & 4     & 0     & 0     & 3     & 1     & 1* \\\hline
    \midrule
    MAINT.Data & Silva (2011) & V     &       & 0     & 0     & 0     & 7*    & 0     & 1* \\
    iRegression & Neto (2011) & V     &       & 0     & 0     & 0     & 1     & 0     & 0 \\
    intReg & Toomet (2012) &       &       & 0     & 0     & 0     & 1     & 0     & 0 \\
    ISDA.R & Filho (2012) &       &       & 1     & 0     & 1     & 1     & 0     & 0 \\
    GPCSIV & Brahim (2013) &       &       & 0     & 0     & 0     & 1     & 0     & 0 \\
    GraphPCA & Brahim (2014) &       &       & 0     & 0     & 0     & 1     & 0     & 0 \\\hline
    \midrule
    ggESDA & Jiang (2021) & V     & V     & 8*    & 4*    & 2*    & 1     & 0     & 0 \\\hline
    \bottomrule
    \end{tabular}}%
  \label{tab:pkgCompare}%
\end{table}%
%end : this is my table for package_compare 

\section{Generalization and Extension}

As far as generalization and extension are concerned, the package provides a simple way for making connections with other useful packages, so that the result of common statistical or machine learning methods on other packages may be visualized as well using \pgk{ggESDA} if it is interval-valued. The following will discuss these explicitly. 

\subsection{General principle}\label{genPrin}

Generally, it is not merely the well-known packages in \proglang{R} that can make a plot using it. As long as keeping some principle, it will be easily performed:

\begin{enumerate}
  \item Understand the data structure clearly if it is an object from other packages.
  \item Extract the min data and max data from it or make some necessary transformation.
  \item Classify the data you extract belong.
  \item Reorganized it and use \code{classic2sym()} for the final transformation.
  \item Visualize the front result using \pgk{ggESDA}.
\end{enumerate}

Because of the interval-valued data, all SDA packages studying in the same field will store and deal with the min and max data. Hence, the transformation method in section \ref{userDef} plays a important role.
With the connection being built, it can be compatible with all other tools in \proglang{R}.


\subsection{Example for generalization}

For the demonstration, we consider two famous \proglang{R} packages for SDA, \pkg{HistDAWass} \cite{irpino2015} and \pkg{MAINT.Data} \cite{Silva2011}. Both of these make lots of contributions to the statistics of SDA, so we tend to make some analysis using these and plot the result with \pkg{ggESDA}.

\subsubsection[HistDAWass]{\pkg{HistDAWass}}

We use the principle in section \ref{genPrin} to process \code{BLOOD} data in \pkg{HistDAWass}, first. With the method \pkg{HistDAWass} provided, it will be more convenient to get min and max data:

<<HistDAWass_getData>>=
library(HistDAWass)
# Get min and max data
blood.min <- get.MatH.stats(BLOOD, stat = "min")
blood.max <- get.MatH.stats(BLOOD, stat = "max")
blood <- data.frame(blood.min, blood.max)

# Reorganized and Build ggESDA obj.
blood.sym <- classic2sym(blood, groupby = "customize",
                     minData = blood[, 2:4],
                     maxData = blood[, 6:8])

# Make names
blood.names <- get.MatH.main.info(BLOOD)$varnames
blood.i <- blood.sym$intervalData
colnames(blood.i) <- blood.names
head(as.data.frame(blood.i), 5)
@

After getting the necessary data, classifying data belonging is vital for reorganization, which means that differentiating the min data and max data. For instance, \code{minData = blood[, 2:4]} represents the min data are the columns of $2,3,4$ in this case.

\subsubsection[MAINT.Data]{\pkg{MAINT.Data}}

However, it is also a common way to store interval-valued data by median and range. In \pkg{MAINT.Data}, the data will exist in this form. Fortunately, a median-range form is not difficult to deal with. We can do the necessary conversion directly to get the data we expect:

<<MAINT.Data_getData>>=
library(MAINT.Data)
#get data interval-valued data in AbaloneIdt
Aba.range <- AbaloneIdt@LogR
Aba.mid <- AbaloneIdt@MidP


#make a necessary transformation for build min max data
Aba <- data.frame(Aba.min = Aba.mid - exp(Aba.range) / 2,
                  Aba.max = Aba.mid + exp(Aba.range) / 2)


# Reorganized and Build ggESDA obj.
Aba.sym<- classic2sym(Aba, groupby = "customize",
                      minData = Aba[, 1:7],
                      maxData = Aba[, 8:14])


# Make names
colnames(Aba.sym$intervalData) <- AbaloneIdt@VarNames
Aba.i <- Aba.sym$intervalData %>% 
  cbind(Aba.obs = AbaloneIdt@ObsNames) %>% 
  column_to_rownames(var = "Aba.obs")
head(Aba.i[, 1:4], 5)
@

In brief, following the general principle in section \ref{genPrin} may facilitate the integration, extend utilize of \pkg{ggESDA} and generalize to all SDA studies.



\begin{figure}[h]	
  		\centering	 			 	
  		%\includepdf[width=1\textwidth]{doc/packageStructure.pdf}
  		%\includesvg[width=1\textwidth]{doc/packageStructure}
 	 		\includegraphics[width=1\textwidth]{doc/packageStructure.png} 
  		\caption{Package Structure and Diagram for the Transformation Flow} 
  		\label{fig:pkgStr}   			 		 
\end{figure}




\bibliography{refs}

\end{document}
